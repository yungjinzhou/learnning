#### 1. 平均负载

##### 1.1 定义
平均负载其实就是平均活跃进程数。平均活跃进程数，直观上的理解就是单位时间内的活跃进程数，但它实际上是活跃进程数的指数衰减平均值。

先查看系统有几个cpu     ```grep 'model name' /proc/cpuinfo | wc -l```, 当平均负载比 CPU 个数还大的时候，系统已经出现了过载。

当平均负载高于 CPU 数量 70% 的时候，你就应该分析排查负载高的问题了。一旦负载过高，就可能导致进程响应变慢，进而影响服务的正常功能。

##### 1.2 常用分析命令

stress 是一个 Linux 系统压力测试工具，这里我们用作异常进程模拟平均负载升高的场
景。

```
运行 stress 命令，模拟一个 CPU 使用率 100% 的场景 
stress --cpu 1 --timeout 600
另一个终端查看
watch -d uptime，查看cpu平均负载

# -P ALL 表示监控所有 CPU，后面数字 5 表示间隔 5 秒后输出一组数据
$ mpstat -P ALL 5

# 间隔 5 秒后输出一组数据，查看哪个进程 的cpu使用率，哪个命令导致的
$ pidstat -u 5 1

CPU 密集型进程特点：
1 分钟的平均负载会慢慢增加到 1.00，而从终端三中还可以看到，
正好有一个 CPU 的使用率为 100%，但它的 iowait 只有 0。这说明，平均负载的升高正
是由于 CPU 使用率为 100% 。



# 运行 stress 命令，但这次模拟 I/O 压力，即不停地执行 sync
stress -i 1 --timeout 600

I/O 密集型进程的特点：
用mpstat -P ALL 5分析
1 分钟的平均负载会慢慢增加到 1.06，其中一个 CPU 的系统 CPU 使用
率升高到了 23.87，而 iowait 高达 67.53%。这说明，平均负载的升高是由于 iowait 的升
高。




大量进程的场景的特点：
当系统中运行进程超出 CPU 运行能力时，就会出现等待 CPU 的进程。
使用 stress，但这次模拟的是 8 个进程
$ stress -c 8 --timeout 600
，8 个进程在争抢 2 个 CPU，每个进程等待 CPU 的时间（也就是代码块中的
%wait 列）高达 75%。这些超出 CPU 计算能力的进程，最终导致 CPU 过载。
```



而 sysstat 包含了常用的 Linux 性能工具，用来监控和分析系统的性能。我们的案例会用
到这个包的两个命令 mpstat 和 pidstat。

mpstat 是一个常用的多核 CPU 性能分析工具，用来实时查看每个 CPU 的性能指标，
以及所有 CPU 的平均指标。
pidstat 是一个常用的进程性能分析工具，用来实时查看进程的 CPU、内存、I/O 以及
上下文切换等性能指标。





#### 2. cpu上下文切换

##### 2.1 上下文的概念

​       上下文：CPU 寄存器，是 CPU 内置的容量小、但速度极快的内存。而程序计数器，则是用来存储CPU 正在执行的指令位置、或者即将执行的下一条指令位置。它们都是 CPU 在运行任何任务前，必须的依赖环境，因此也被叫做 CPU 上下文。

​        CPU 上下文切换：就是先把前一个任务的 CPU 上下文（也就是 CPU 寄存器和程序计数器）保存起来，然后加载新任务的上下文到这些寄存器和程序计数器，最后再跳转到程序计数器所指的新位置，运行新任务。



##### 2.2 进程上下文切换

​        Linux 按照特权等级，把进程的运行空间分为内核空间和用户空间。从用户态到内核态的转变，需要通过系统调用来完成。一次系统调用实际发生了两次cpu上下文切换。

```
系统调用：CPU 寄存器里原来用户态的指令位置，需要先保存起来。接着，为了执行内核态代码，CPU 寄存器需要更新为内核态指令的新位置。最后才是跳转到内核态运行内核任务。而系统调用结束后，CPU 寄存器需要恢复原来保存的用户态，然后再切换到用户空间，继续运行进程
```

​        需要注意的是，系统调用过程中，并不会涉及到虚拟内存等进程用户态的资源，也不会切换进程。所以，系统调用过程通常称为特权模式切换，而不是上下文切换。

​        进程是由内核来管理和调度的，进程的切换只能发生在内核态。所以，进程的上下文不仅包括了虚拟内存、栈、全局变量等用户空间的资源，还包括了内核堆栈、寄存器等内核空间的状态。

​        进程切换的条件：

```
1. 当某个进程的时间片耗尽了，就会被系统挂起，切换到其它正在等待 CPU 的进程运行。
2. 进程在系统资源不足（比如内存不足）时，要等到资源满足后才可以运行，这个时候进程也会被挂起，并由系统调度其他进程运行。
3. 当进程通过睡眠函数 sleep 这样的方法将自己主动挂起时，自然也会重新调度。
4. 当有优先级更高的进程运行时，为了保证高优先级进程的运行，当前进程会被挂起，由高优先级进程来运行。
5. 发生硬件中断时，CPU 上的进程会被中断挂起，转而执行内核中的中断服务程序。
```



##### 2.3 线程上下文切换

线程与进程最大的区别在于，线程是调度的基本单位，而进程则是资源拥有的基本单位。

所谓内核中的任务调度，实际上的调度对象是线程；而进程只是给线程提供了虚拟内存、全局变量等资源。

##### 2.4 中断上下文切换

​        为了快速响应硬件的事件，中断处理会打断进程的正常调度和执行，转而调用中断处理程序，响应设备事件。而在打断其他进程时，就需要将进程当前的状态保存下来，这样在中断结束后，进程仍然可以从原来的状态恢复运行。

​        跟进程上下文不同，中断上下文切换并不涉及到进程的用户态。中断上下文，其实只包括内核态中断服务程序执行所必需的状态，包括 CPU 寄存器、内核堆栈、硬件中断参数等。
​        对同一个 CPU 来说，中断处理比进程拥有更高的优先级，所以中断上下文切换并不会与进程上下文切换同时发生。同样道理，由于中断会打断正常进程的调度和执行，所以大部分中断处理程序都短小精悍，以便尽可能快的执行结束。



##### 2.5 查看系统上下文切换

可以使用 vmstat 这个工具，来查询系统的上下文切换情况。

```
# 每隔 5 秒输出 1 组数据
$ vmstat 5
procs -----------memory---------- ---swap-- -----io---- -system-- ------cpu-----
r b swpd free buff cache si so bi bo in cs us sy id wa st
0 0 0 7005360 91564 818900 0 0 0 0 25 33 0 0 100 0 0

cs（context switch）是每秒上下文切换的次数。
in（interrupt）则是每秒中断的次数。
r（Running or Runnable）是就绪队列的长度，也就是正在运行和等待 CPU 的进程
数。
b（Blocked）则是处于不可中断睡眠状态的进程数。


```

vmstat 只给出了系统总体的上下文切换情况，要想查看每个进程的详细情况，就需要使用
我们前面提到过的 pidstat 了

```
$ pidstat -w 5
Linux 4.15.0 (ubuntu) 09/23/18 _x86_64_ (2 CPU)
08:18:26 UID PID cswch/s nvcswch/s Command
08:18:31 0 1 0.20 0.00 systemd
08:18:31 0 8 5.40 0.00 rcu_sched


一个是 cswch ，表示每秒自愿上下文切换
（voluntary context switches）的次数，另一个则是 nvcswch ，表示每秒非自愿上下文
切换（non voluntary context switches）的次数。

所谓自愿上下文切换，是指进程无法获取所需资源，导致的上下文切换。比如说，I/O、内存等系统资源不足时，就会发生自愿上下文切换。
而非自愿上下文切换，则是指进程由于时间片已到等原因，被系统强制调度，进而发生的上下文切换。比如说，大量进程都在争抢 CPU 时，就容易发生非自愿上下文切换。
```



##### 2.6 模拟上下文切换

使用 sysbench 来模拟系统多线程调度切换的情况。

sysbench 是一个多线程的基准测试工具，一般用来评估不同系统参数下的数据库负载情
况。当然，在这次案例中，我们只把它当成一个异常进程来看，作用是模拟上下文切换过
多的问题



```
# 以 10 个线程运行 5 分钟的基准测试，模拟多线程切换的问题
$ sysbench --threads=10 --max-time=300 threads run

分析cpu 队列，中断，切换次数
每隔 1 秒输出 1 组数据（需要 Ctrl+C 才结束）
$ vmstat 1

# 每隔 1 秒输出 1 组数据（需要 Ctrl+C 才结束）
# -w 参数表示输出进程切换指标，而 -u 参数则表示输出 CPU 使用指标， # -wt 参数表示输出线程的上下文切换指标
$ pidstat -w -u 1

读取中断信息
# -d 参数表示高亮显示变化的区域
$ watch -d cat /proc/interrupts

变化速度最快的是重调度中断（RES），这个中断类型表示，唤醒空闲状态的 CPU 来调度新的任务运行。这是多处理器系统（SMP）中，调度器用来分散任务到不同 CPU 的机制，通常也被称为处理器间中断（Inter-ProcessorInterrupts，IPI）。


```



##### 2.7 cpu切换多少正常

​         这个数值其实取决于系统本身的 CPU 性能。在我看来，如果系统的上下文切换次数比较稳定，那么从数百到一万以内，都应该算是正常的。但当上下文切换次数超过一万次，或者切换次数出现数量级的增长时，就很可能已经出现了性能问题。
​         比方说：自愿上下文切换变多了，说明进程都在等待资源，有可能发生了 I/O 等其他问题；非自愿上下文切换变多了，说明进程都在被强制调度，也就是都在争抢 CPU，说明 CPU的确成了瓶颈；中断次数变多了，说明 CPU 被中断处理程序占用，还需要通过查看 /proc/interrupts文件来分析具体的中断类型。















