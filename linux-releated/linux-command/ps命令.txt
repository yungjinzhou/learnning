linux上进程有5种状态: 
1. 运行(正在运行或在运行队列中等待) 
2. 中断(休眠中, 受阻, 在等待某个条件的形成或接受到信号) 
3. 不可中断(收到信号不唤醒和不可运行, 进程必须等待直到有中断发生) 
4. 僵死(进程已终止, 但进程描述符存在, 直到父进程调用wait4()系统调用后释放) 
5. 停止(进程收到SIGSTOP, SIGSTP, SIGTIN, SIGTOU信号后停止运行运行) 

ps工具标识进程的5种状态码: 
D 不可中断 uninterruptible sleep (usually IO) 
R 运行 runnable (on run queue) 
S 中断 sleeping 
T 停止 traced or stopped 
Z 僵死 a defunct (”zombie”) process 

命令参数：
a  显示所有进程
-a 显示同一终端下的所有程序
-A 显示所有进程
c  显示进程的真实名称
-N 反向选择
-e 等于“-A”
e  显示环境变量
f  显示程序间的关系
-H 显示树状结构
r  显示当前终端的进程
T  显示当前终端的所有程序
u  指定用户的所有进程
-au 显示较详细的资讯
-aux 显示所有包含其他使用者的行程 
-C<命令> 列出指定命令的状况
--lines<行数> 每页显示的行数
--width<字符数> 每页显示的字符数
--help 显示帮助信息
--version 显示版本显示

1.pa aux（与ps -aux结果一致）:
USER：用户名? 
PID ：该进程的进程ID号。
CPU：该进程使用掉的 CPU 资源百分比；
MEM：该进程所占用的物理内存百分比；
VSZ ：该进程使用掉的虚拟内存量 (Kbytes)
RSS ：该进程占用的固定的内存量 (Kbytes)
TTY ：该进程是在那个终端机上面运作，若与终端机无关，则显示 ?，另外， tty1-tty6 是本机上面的登入者程序，若为 pts/0 等等的，则表示为由网络连接进主机的程序。
STAT：该程序目前的状态，主要的状态有：
	R 运行? ? Runnable (on run queue)? ? ? 正在运行或在运行队列中等待。?????????????? 
	S 睡眠??? Sleeping??? ??? ??? ??? 休眠中, 受阻, 在等待某个条件的形成或接受到信号。??????????????? 
	I 空闲??? Idle???????????????? 
	Z 僵死??? Zombie（a defunct process)??? ??? 进程已终止, 但进程描述符存在, 直到父进程调用wait4()系统调用后释放。????????????????? 
	D 不可中断??? Uninterruptible sleep (ususally IO)??? 收到信号不唤醒和不可运行, 进程必须等待直到有中断发生。?????????????????? 
	T 终止??? Terminate??? ??? ??? ??? 进程收到SIGSTOP, SIGSTP, SIGTIN, SIGTOU信号后停止运行运行。?????????????????? 
	P 等待交换页?????????????????? 
	W 无驻留页??? has no resident pages??? ??? 没有足够的记忆体分页可分配。???????????????????
	X 死掉的进程????????? 
	< 高优先级进程??? ???? 高优先序的进程??????????????????? 
	N 低优先??? 级进程??? ???  低优先序的进程??????????????????? 
	L 内存锁页??? Lock??? ???  有记忆体分页分配并缩在记忆体内??????????????????? 
	s 进程的领导者（在它之下有子进程）；???????????????????? 
	l 多进程的（使用 CLONE_THREAD, 类似 NPTL pthreads）???????????????????? 
	+ 位于后台的进程组
START：进程启动时间和日期；
TIME ：进程使用的总cpu时间。
COMMAND：正在执行的命令行命令





实例
ps -aux --sort -pcpu | less：通过 --sort命令根据 CPU 使用来升序排序
ps -aux --sort -pmem | less：通过 --sort命令根据 内存使用 来升序排序
ps -aux --sort -pcpu,+pmem | head -n 10：根据CPU使用和内存使用升序排列，并通过管道显示前10个结果
ps -C java：显示java的进程信息，没有ps aux|grep java、ps -ef|grep java 显示的详细
ps -L PID：根据线程来过滤进程
ps -axjf和pstree：树形显示进程
	以树状图显示进程同时还显示PID：pstree -p
	以树状图显示进程PID的进程以及子孙进程，如果有-p参数则同时显示每个进程的PID  pstree -p pid
ps -eo pid,user,args：参数 -e 显示所有进程信息，-o 参数控制输出。Pid,User 和 Args参数显示PID，运行应用的用户和该应用。可以查看现在有谁登入了你的服务器




在Linux下，可以有两种比较方便的方法：
1. # pstree
通过系统的进程树来查看某个进程的父进程；
2. # ps -ef |grep <进程名>
在显示的输出中，第三列就是该进程的父进程PID，然后可以再使用ps命令来查看父进程的名称
# ps -ef |grep <父进程PID>


[root@apm-test lib]# ps -ef | grep uwsgi
root     11398     1  0 Mar25 ?        00:00:33 uwsgi --ini lib/apm/applications/apmapi/apmapi.ini
root     11402 11398  0 Mar25 ?        00:00:00 uwsgi --ini lib/apm/applications/apmapi/apmapi.ini
root     11403 11398  0 Mar25 ?        00:00:00 uwsgi --ini lib/apm/applications/apmapi/apmapi.ini

[root@apm-test lib]# ps --ppid 1 | grep uwsgi
11398 ?        00:00:33 uwsgi
指定ppid即父进程，查看uwsgi的父进程id


僵尸进程是该进程执行完毕或者因故终止，但是该进程的父进程无法完整将该进程结束掉，造成那个进程一直在内存中。如果发现进程的CMD后面有defunct，代表该进程是僵尸进程。

init进程是所有进程的父进程，进程pid是1



echo $$打印当前shell的进程pid


ps查看所有进程
pid 进程号
ppid 父进程号
uid 用户号




